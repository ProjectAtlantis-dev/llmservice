
<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <!--meta http-equiv="cache-control" content="no-cache"/-->
    <meta name="description" content="Project Atlantis">
    <meta name="theme-color" content="#00000099" />
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Project Atlantis</title>
    <base href="/">

    <link rel="icon" href="/favicon.ico">

    <link href="/style/style_fonts.css" type="text/css" rel='stylesheet'/>
    <link href="/style/style_scroll.css" type="text/css" rel='stylesheet'/>
    <link href="/style/style_base.css" type="text/css" rel='stylesheet'/>
    <link href="/style/style_glowie.css" type="text/css" rel='stylesheet'/>
    <link href="/style/style_home.css" type="text/css" rel='stylesheet'/>
    <link href="/style/style_chat.css" type="text/css" rel='stylesheet'/>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha512-KfkfwYDsLkIlwQp6LFnl8zNdLGxu9YAA1QvwINks4PhcElQSvqcyVLLD9aMhXd13uQjoXtEKNosOWaZqXgel0g==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.0-dev.20220410/min/vs/editor/editor.main.min.css" integrity="sha512-EjJksa60Dx+Ed/wwChZ50y92Xj6qqfh6Z/Qswjcyf4hF3/gMmuJhmUIHalh1WgJRYJsdi3/nesNboAyN03J9ZA==" data-name="vs/editor/editor.main"  crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/a11y-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-dark.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.0.0/mermaid.dark.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.4/d3.min.js"></script>

    <script src="/bundle.js"></script>

</head>
<body id="body">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.0-dev.20220410/min/vs/loader.min.js" integrity="sha512-O9SYDgWAM3bEzit1z6mkFd+dxKUplO/oB8UwYGAkg2Zy/WzDUQ2mYA/ysk3c0CxiXAN4u8T9JeZ0Ahk2Jj/33Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


    <div id="outerView" style="visibility: hidden;">

        <div id="wrapperView">
            <div id="contentView" style="font-size:14pt;">

                <div id="chatForm" style="height:100%; display:flex; flex-direction: column;justify-content:flex-start;">


                    <div id="chatHeader" style="flex:0; ">
                        <div id="topBanner" class="bot-terminal-row" style="white-space: normal; padding:1px; margin: 10px">

                            <div id="logoBanner" class="jetage" style="flex:0; white-space:nowrap; letter-spacing:1vmax; padding-left:1vmax; width:100%; font-size:3vmax; -webkit-font-smoothing: subpixel-antialiased; -webkit-text-fill-color: transparent; background-clip: text; -webkit-background-clip: text; background-image: linear-gradient(45deg,#99ffff, #0000aa); text-shadow: 2px 2px 3px  #0005">
                                ATLANTIS
                            </div>

                            <div style="flex:1;">
                            </div>

                            <div style="padding-left:1ch">
                            </div>

                            <!--div id="backButton" class="glowie glowie-button glowie-border glowie-nordie horseshoe" style="flex: 0;opacity:0.7">
                                Back
                            </div-->


                        </div>
                    </div>

                    <div id="chatTerminal" style="flex:2; padding:10px; display:flex; flex-direction:row;  ">

                        <div id="chatEditor" style="flex:1; flex-basis:0; border:1px solid #9090c0; display:flex; flex-direction:column" >
                            <div id="editor" style="min-width:100px; height:100% ; padding:10px" ></div>
                            <div id="editorFooter" style="flex:0; display:flex; flex-direction:row; margin-left:10px;margin-right:10px;margin-bottom:10px">

                                <div id="editorFooterPicker" style="flex:1;white-space:nowrap; display:flex; flex-direction:row;align-items:center; justify-content:center">

                                    <div style="flex:1; padding-left: 10px; padding-right: 1ch; display:flex; flex-direction:row; align-items:center">
                                        <div style="flex:0; padding-right: 1ch;">Model</div>
                                        <div class="select" style="flex-shrink: 0; ">
                                            <select id="model-select" ></select>
                                        </div>
                                    </div>

                                </div>
                                <div id="editorFooterMiddle" style="flex:1"></div>
                                <div id="editorFooterStatus" style="flex:0; white-space:pre;padding-right:1ch">Tokens: 0</div>

                            </div>

                        </div>

                        <div id="chatFeedback" style="flex:1; flex-basis:0;margin-left:20px; border: 1px solid #9090c0;padding:10px; display:flex;flex-direction:column" >
                            <div id="feedback" style="flex:1; flex-basis:0; min-height:100px; min-width:100px; overflow-y:auto" ></div>
                        </div>

                        <div id="chatContextArea" style="flex:1; flex-basis:0; margin-left:20px;overflow-y: auto; border: 1px solid #9090c0;padding:10px  " >

                            <div id="context" style="min-width:100px; " ></div>

                        </div>


                    </div>

                    <div id="chatMessages" style="flex:1; margin:10px; flex-basis:0; overflow-y: auto; font-size:10pt; border: 1px solid #9090c0;padding:10px">
                        <div id="messages" style="min-width:100px; " ></div>
                    </div>

                    <div id="chatFooter" style="flex:0; display:flex; flex-direction:row; margin-left:10px;margin-right:10px;margin-bottom:10px">
                        <div id="chatFooterStatus" style="flex:0; white-space:pre">Hello</div>
                        <div id="chatFooterMiddle" style="flex:1"></div>
                        <div id="chatFooterUser" style="flex:0;white-space:nowrap"></div>
                    </div>



                </div>
            </div>

        </div>

    </div>


</body>
</html>


<script type="module">

import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';


let thread = threadManager.get("main");

thread.console.info("Loaded page");

let getElementById = function(path) {
    let el = document.getElementById(path);
    if (!el) {
        throw new Error("Unable to find element: " + path);
    }
    return el;
}

let startEditor = function(editorTag, callbackObj) {

    thread.console.info("Starting editor");

    // NOTE we are using vs-specific async 'require' provided by loader.min.js
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.0-dev.20220410/min/vs' }});

    let container = getElementById(editorTag);

    let init = async function() {

        thread.console.info("Initializing editor");

        // no easy way to add custom syntax highlighting so we have to roll our own

        // get typescript
        let allLangs = monaco.languages.getLanguages();

        const { conf, language: tsLang } = await allLangs.find(({ id }) => id ==='typescript').loader();

        //thread.console.debug("conf", conf);
        //thread.console.debug("ts before", tsLang);

        let customTokenizer = {
            tokenizer: {
                whitespace: [
                    [ /\/\/[ ]*[\%].*$/, 'botcommentline' ]
                ]
            }
        };

        // now hack the tokenizer like a crazy person
        for (let key in customTokenizer) {
            const value = customTokenizer[key];
            if (key === 'tokenizer') {
                for (let category in value) {
                    //thread.console.debug("tokenizer", value);
                    const tokenDefs = value[category];
                    //thread.console.debug("token defs", tokenDefs);
                    if (!tsLang.tokenizer.hasOwnProperty(category)) {
                        thread.console.debug("adding category [" + category + "]");
                        tsLang.tokenizer[category] = [];
                    }
                    if (Array.isArray(tokenDefs)) {
                        tsLang.tokenizer[category].unshift.apply(tsLang.tokenizer[category], tokenDefs)
                    }
                    //thread.console.debug(category + " category after", tsLang.tokenizer[category]);
                }
            } else if (Array.isArray(value)) {
                if (!tsLang.hasOwnProperty(key)) {
                    tsLang[key] = [];
                }
                    tsLang[key].unshift.apply(tsLang[key], value)
            }
        }

        //thread.console.debug("ts after", tsLang);

        // decorations
        monaco.editor.defineTheme('bot', {
            base: 'vs-dark',
            inherit: true,
            colors: {},
            rules: [
                { token: 'botcommentline', foreground: '9090c0' }
            ]
        });

        let ed = monaco.editor.create(container, {
            value: "",
            //language: 'python',
            //language: 'typescript',
            fontSize: 14,
            quickSuggestions: {
                "other": false,
                "comments": false,
                "strings": false
            },
            theme: 'bot',
            minimap: {
                enabled: false
            },
            automaticLayout: true // auto-resize,
        });



        return ed;
    };

    let p = new Promise(function(resolve, reject) {

        try {
            let currWidth = window.innerWidth;
            let currHeight = window.innerHeight;
            require(["vs/editor/editor.main"], async function() {

                thread.console.info("Doing editor setup");

                let editorSetup = async function() {

                    let ed = await init();

                    let container = getElementById("editor");
                    new ResizeObserver(function() {

                        //thread.console.info("width: " + window.innerWidth);
                        //thread.console.info("height: " + window.innerHeight);

                        if (window.innerWidth < currWidth || window.innerHeight < currHeight) {
                            // shrink hack; still wipes out rendering unless user increases size slightly afterwards
                            ed.layout({});
                        }

                        currWidth = window.innerWidth;
                        currHeight = window.innerHeight;

                    }).observe(container);

                    return ed;
                }

                let editor = await editorSetup();

                editor.onContextMenu((e) => {
                    // Check if the event is triggered by pressing the 'Ctrl' key
                    if (e.event.ctrlKey) {
                    // Prevent the context menu from appearing
                    e.event.preventDefault();
                    }
                });

                let getTelemetry = function() {
                    let content = editor.getValue();

                    let position = editor.getPosition();
                    //thread.console.debug("cursor position", position);
                    // position.lineNumber, position.column

                    let offset = editor.getModel().getOffsetAt(position);
                    //thread.console.debug("cursor offset", offset);

                    const lastColumn = editor.getModel().getLineLastNonWhitespaceColumn(position.lineNumber);
                    let range = new monaco.Range(position.lineNumber, 1, position.lineNumber,lastColumn+1);
                    //thread.console.debug("range", range)

                    let buffer = editor.getModel().getValueInRange(range);

                    return {
                        content,
                        range,
                        buffer // everything from current line to end
                    }
                }

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.RightArrow, async function() {
                    thread.console.info("Got ctrl right arrow");

                    let {content,range, buffer} = getTelemetry();

                    // move cursor down
                    //editor.getAction('cursorDown').run();
                    //editor.revealLineInCenter(position.lineNumber+1);

                    //editor.revealLine(position.lineNumber+1);
                    //editor.setPosition({column: 1, lineNumber: position.lineNumber+1});

                    {
                        // flash current line

                        thread.console.debug("Turning on highlight");
                        let foo = editor.deltaDecorations([], [
                            {
                                range,
                                options: {
                                    isWholeLine: true,
                                    inlineClassName: 'lineHighlight'
                                }
                            }
                        ]);

                        setTimeout(function() {
                            thread.console.debug("Turning off highlight");
                            editor.deltaDecorations(foo, []);
                        },200);
                    }

                    // run command
                    if (callbackObj && callbackObj.run) {
                        callbackObj.run(buffer, range, content);
                    } else {
                        thread.console.info("Command dropped due to lack of callback: " + buffer);
                    }

                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.LeftArrow, async function() {
                    thread.console.info("Got ctrl left arrow");

                    let {content,range, buffer} = getTelemetry();

                    // run command
                    if (callbackObj && callbackObj.clear) {
                        callbackObj.clear(buffer, range, content);
                    } else {
                        thread.console.info("Clear dropped due to lack of callback: " + buffer);
                    }

                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.UpArrow, async function() {
                    thread.console.info("Got ctrl up arrow");
                    //await editorApp.admin("up");
                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.DownArrow, async function() {
                    thread.console.info("Got ctrl down arrow");
                    //await editorApp.admin("down");
                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.UpArrow, async function() {
                    thread.console.info("Got scroll up arrow");
                    //await editorApp.admin("scrollUp");
                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.DownArrow, async function() {
                    thread.console.info("Got scroll down arrow");
                    //await editorApp.admin("scrollDown");
                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.RightArrow, async function() {
                    thread.console.info("Got scroll right arrow");
                    //await editorApp.admin("scrollRight");
                });

                editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.LeftArrow, async function() {
                    thread.console.info("Got scroll left arrow");
                    //await editorApp.admin("scrollLeft");
                });

                /*
                class StartupMessageOverlayWidget {
                    constructor(editor) {
                        this._editor = editor;
                        this._domNode = document.createElement('div');
                        this._domNode.className = 'startupMessageOverlayWidget';
                        this._domNode.textContent = 'Welcome to the Monaco Editor!';
                        this._domNode.style.background = '#000';
                        this._domNode.style.padding = '30px';
                        this._domNode.style.borderRadius = '5px';
                        this._domNode.style.position = 'absolute';
                        this._domNode.style.zIndex = '1000';
                        this._domNode.style.top = '-50%';
                        this._domNode.style.left = '50%';
                        this._domNode.style.transform = 'translate(-50%, 50%)';

                        // Add a close button
                        this._closeButton = document.createElement('button');
                        this._closeButton.textContent = 'X';
                        this._closeButton.style.position = 'absolute';
                        this._closeButton.style.right = '5px';
                        this._closeButton.style.top = '5px';
                        this._closeButton.style.cursor = 'pointer';
                        this._domNode.appendChild(this._closeButton);

                        // Add a click event listener to the close button
                        this._closeButton.addEventListener('click', () => {
                            this._editor.removeOverlayWidget(this);
                        });
                    }

                    getId() {
                        return 'StartupMessageOverlayWidget';
                    }

                    getDomNode() {
                        return this._domNode;
                    }

                    getPosition() {
                        return {
                            preference: [monaco.editor.ContentWidgetPositionPreference.ABOVE, monaco.editor.ContentWidgetPositionPreference.BELOW]
                        };
                    }
                }

                const startupMessageOverlayWidget = new StartupMessageOverlayWidget(editor);
                editor.addOverlayWidget(startupMessageOverlayWidget);
                */



                let foo = function() {
                    let {content,range, buffer} = getTelemetry();
                    if (callbackObj && callbackObj.keydown) {
                        callbackObj.keydown(buffer, range, content);
                    }
                }

                let debouncedFoo = util.debounce(foo, 500)

                let ctrlPressed = false;
                window.addEventListener("keydown", async function(e) {
                    //thread.console.debug("got keypress", e.key);

                    if (e.key === 'Meta' || e.key === 'Control') {
                        //thread.console.info("GOT CTRL");
                        ctrlPressed = true;
                    }

                    if (e.key === 's' && ctrlPressed) {
                        e.preventDefault();
                        ctrlPressed = false;

                        let {content,range, buffer} = getTelemetry();

                        thread.console.info("GOT SAVE");

                        // run command
                        if (callbackObj && callbackObj.save) {
                            callbackObj.save(buffer, range, content);
                        } else {
                            thread.console.info("Save dropped due to lack of callback: " + buffer);
                        }

                    }

                    if (e.key === "F5") {
                        event.preventDefault();

                    }

                    // run command
                    debouncedFoo();


                });


                resolve(editor);

            });

        } catch (err) {
            reject(err.toString());
        }
    });


    return p;
}


let run = async function() {
    try {
        thread.console.info("Running with scissors");


        //let wrapper = getElementById("chatInnerWrapper");
        //let backgroundImage = "/images/greenland3.png";

        //wrapper.style.backgroundSize = 'cover';
        //wrapper.style.backgroundRepeat = 'no-repeat';
        //wrapper.style.backgroundImage = "url('" + backgroundImage + "')";


        // wrapper background
        let zc = util.colorLuminance("#fff", -0.97);
        let lum = 0.8   // 10% of total light
        let rgba = util.hexToRGBA(zc, lum);

        //let content = getElementById("chatCover");
        //let lgStr = "linear-gradient(to right, rgba(0,0,0,0.99), rgba(0,0,0,.99) 0%, " + rgba + ")";
        //content.style.background = rgba;

        // JS must be enabled
        let outerView = getElementById("outerView");
        outerView.style.visibility = "visible";


        let editorCallbackObj = {};

        let ed = await startEditor("editor", editorCallbackObj);

        let mainEditor = new Editor();
        mainEditor.run(ed, editorCallbackObj, mermaid, d3);





    } catch (err) {
        thread.console.softError(err);
    }
}



window.onload = run;


</script>
